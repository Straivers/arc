module arc.syntax.location;

alias CharPos = uint;

/**
 * A Span represents a contiguous region of code starting from `start` and
 * ending at `start + length` exclusive.
 *
 * The lack of a reference to the file that this span belongs to necessitates
 * that the information be stored elsewhere.
 */
struct Span {
    /// The index of the first character in the span
    CharPos start;
    /// The length of the span
    CharPos length;

    CharPos end() const { return start + length; }

    Span merge(Span other) const {
        auto lo = start < other.start ? start : other.start;
        auto hi_end = end > other.end ? end : other.end;
        return Span(lo, hi_end - lo);
    }
}

@("span:merge") unittest {
    auto a = Span(10, 20);
    auto b = Span(5, 15);
    auto c = Span(15, 25);
    auto d = Span(5, 25);
    assert(a.merge(a) == Span(10, 20));
    assert(a.merge(b) == Span(5, 25));
    assert(a.merge(c) == Span(10, 30));
    assert(a.merge(d) == Span(5, 25));
    assert(b.merge(c) == Span(5, 35));
}

struct SpannedText {
    Span span;
    const(char)[] text;

    alias span this;

    this(CharPos start, CharPos length, const(char)[] text) {
        this.span = Span(start, length);
        this.text = text;
    }
    
    SpannedText get_span(const(char)[] slice) {
        const offset = cast(uint) (slice.ptr - text.ptr);
        const length = cast(uint) slice.length;
        return SpannedText(cast(uint) (span.start + offset), length, slice);
    }

    const(char)[] get_text(Span text_span) {
        auto local = local_span(text_span);
        return local.text;
    }

    SpannedText merge(SpannedText other) {
        auto global = span.merge(other.span);
        auto local = local_span(global);
        return SpannedText(global.start, global.length, local.text);
    }

    Span merge(Span other) const {
        return span.merge(other);
    }

    SpannedText local_span(Span s) {
        const lo = s.start - span.start;
        const hi = s.end - span.start;

        return SpannedText(lo, hi, text[lo .. hi]);
    }
}

/**
 * A Source represents the source text of a file or autogenerated snippet of
 * code.
 */
struct Source {
    /// The name of the source, or its path
    string name;
    ///
    const(char)[] raw_text;
    /// The absolute span that the source covers
    Span span;
    alias span this;

    bool opBinaryRight(string op = "in")(CharPos pos) {
        return start <= pos && pos < end;
    }
}

/**
 * The SourceMap presents a mapping between character positions and the files
 * that they belong to.
 */
struct SourceMap {
    Source[] sources;

    /**
     * Reserve space for a source of size `source_length`.
     *
     * Returns: the allocated character array to be filled
     */
    Source reserve(string name, uint source_length) {
        return put(name, new const(char)[](source_length));
    }

    Source put(string name, const(char)[] text) {
        const last = sources[$-1];
        if (last.end + text.length > uint.max)
            assert(false);

        auto src = Source(
            name.dup,
            text,
            Span(last.end, cast(CharPos) (last.end + text.length))
        );

        sources ~= src;
        return src;
    }

    Source get_source(CharPos pos) {
        // binary search for the source
        if (sources.length > 0) {
            size_t left = 0;
            size_t right = sources.length - 1;
            size_t mid = sources.length / 2;

            while (pos !in sources[mid]) {
                mid = (mid + right) / 2;
                if (sources[mid].end < pos)
                    left = mid + 1;
                else if (pos < sources[mid].start)
                    right = mid - 1;
                else
                    return sources[mid];
            }
            assert(0, "unreachable");
        }
        else {
            return Source();
        }
    }

    const(char)[] get_text(Span span) {
        auto src = get_source(span.start);
        return src.raw_text[span.start - src.start .. span.length];
    }
}
